\documentclass[a4paper,11pt]{article}
\usepackage{indentfirst}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}
\usepackage[top=2cm, bottom=2cm, left=1cm, right=1cm]{geometry}
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength\parindent{24pt}
\makeatletter
\newcommand{\linia}{\rule{\linewidth}{0.4mm}}
\renewcommand{\maketitle}{\begin{titlepage}
    \vspace*{2cm}
    \begin{center}\LARGE
    Politechnika Warszawska\\
    Wydział Elektryczny\\
    \end{center}
    \vspace{5cm}
    \noindent\linia
    \begin{center}
      \LARGE \textsc{\@title}
         \end{center}
     \linia
    \vspace{0.5cm}
    \begin{flushright}
    \begin{minipage}{5cm}
    \textit{Autor:}\\
    \normalsize \textsc{\@author} \par
    \end{minipage}
    \vspace{5cm}
     \end{flushright}
    \vspace*{\stretch{6}}
    \begin{center}
    \@date
    \end{center}
  \end{titlepage}
}
\makeatother
\author{Grzegorz Kopyt\\Arkadiusz Michalak}
\title{Sprawozdanie}
\usepackage{graphicx}

\fancyhf{}
\fancyhead[CO,CE]{ Grzegorz Kopyt Arkadiusz Michalak \\ Projekt grupowy - Sprawozdanie \\ \today }

\rfoot{\thepage{}/\pageref{LastPage}}

\begin{document}

\maketitle

\tableofcontents
\vspace{1cm}
\noindent\linia
\section{Cel powstania dokumentu}
Rozważanym w projekcie problemem był podział płaszczyzny na obszary optymalne względem punktów kluczowych. Poniższe sprawozdanie ma na celu podsumowanie pracy nad projektem i przedstawienie rozwiązania problemu. Dodatkowo została w nim zawarta subiektywna ocena sposobu prowadzenia laboratoriów przedmiotu Algorytmy i Struktury Danych.

\noindent\linia
\section{Opis problemu}
Podstawowym problemem był podział płaszczyzny ograniczonej konturem względem punktów kluczowych. W taki sposób żeby dowolny punkt dzielonej płaszczyzny znajdował się bliżej swojego punktu kluczowego niż~dowolnego innego. Istotnym zagadnieniem powiązanym z głównym problemem było przedstawienie graficzne tej~płaszczyzny. Dodatkowo program miał umożliwiać nanoszenie na płaszczyznę obiektów. Kolejnym problemem była statystyka owych obiektów dla każdego obszaru jak również całej płaszczyzny. Ostatnie wymaganie problemowe to modyfikacja konturu ograniczającego płaszczyznę jak i usytuowania punktów kluczowych na żywo. 

\noindent\linia
\section{Wysoko abstrakcyjny opis działania programu}
Współrzędne płaszczyzny na której operujemy zostały przybliżone do jednej cyfry po przecinku. To powoduje dyskretny podział na punkty co jest kluczowe dla działania algorytmu obliczania obszarów.
Sposób działanie programu przedstawia się następująco:
\begin{itemize}
\item  wczytanie pliku danych od użytkownika,
\item  weryfikacja konturu pod względem wypukłości i spójności,
\item  weryfikacja punktów kluczowych pod względem przynależności do zadanego konturu
\item jeśli po weryfikacji dane są poprawne rozpoczyna się obliczanie przynależności punktów płaszczyzny do~punktów kluczowych:
\begin{itemize}
\item dla każdego punktu z zakresu od 0 do 99,9 znajdujemy najbliższy  punkt kluczowy porównując odległości~do wszystkich punktów,
\item do punktu kluczowego znajdującego się najbliżej przypisujemy obecnie sprawdzany punkt.
\end{itemize}
\item utworzona w ten sposób struktura punktów kluczowych z przypisanymi punktami płaszczyzny posłuży do~odzwierciedlenia obszarów graficznie,
\item następnie dodawane są obiekty użytkownika,
\item weryfikowana jest ich poprawność oraz określana~jest przynależność do punktu kluczowego analogicznie jak~dla~punktów płaszczyzny,
\item następnie przy użyciu biblioteki graficznej rysowany jest obszar ograniczony konturem, podzielony względem punktów kluczowych, same punkty kluczowe i obiekty użytkownika.
\end{itemize}


\noindent\linia
\section{Efekty działania programu}
W czasie trwania projektu udało się zrealizować wszystkie wymagane funkcjonalności. Najlepszą prezentacją tego jak program działa jest jego uruchomienie. Jednak krótki opis działania poszczególnych funkcjonalności zostanie wypunktowany poniżej.
\subsection{Obsługa plików}
Program dysponuje wczytywaniem plików tekstowych opisujące parametry do analizy. Umożliwia również podłożenie tła będące plikiem graficznym w jednym z formatów \textit{.png , .jpeg , .gif}. Wybór plików odbywa się w~sposób intuicyjny, pozwalający użytkownikowi wskazać tylko pliki o odpowiednim rozszerzeniu z dowolnego folderu komputera. Przy wczytywaniu pliku tekstowego zatroszczono się o szczegółową weryfikacje jego poprawności. Umożliwia to zakomunikowanie użytkownikowi w której linii pojawiły się błędne dane i jakiego rodzaju był to błąd.
\subsection{Rysowanie obszaru}
W sposób wiarygodny przy użyciu narzędzia \textit{canvas} odzwierciedlany jest obliczony podział. Obszary są kolorowe co dodaje atutów wizualnych całości programu. Punktom kluczowym ze względu na ich istotność przypisano kolor czerwony i większy rozmiar względem obiektów użytkownika. Całość charakteryzuje się dużą przejrzystością i czytelnością nawet po podstawieniu kolorowego tła.
\subsection{Statystyka obiektów użytkownika}
Weryfikowane zgodnie z założeniami obiektu użytkownika również są nanoszone na analizowany obszar. Przypisano im kolor fioletowy. Najbardziej istotnym działaniem jest podsumowywanie obiektów użytkownika na danym obszarze. W trybie pracy \textbf{"Wyświetlanie statystyk"} użytkownik może w prosty sposób kliknąć wybrany obszar i wyświetlić wybrany rodzaj prezentacji danych:
\begin{itemize}
\item listę wszystkich obiektów,
\item pogrupowaną listę obiektów,
\item liczbę mieszkańców.
\end{itemize}
Wyświetlone zostaną w nowym oknie, ta część programu działa bardzo sprawnie gdyż przynależności obiektów są~weryfikowane podczas modyfikacji analizowanego obszaru.
\subsection{Modyfikacja na żywo}
Program umożliwia zmianę konturu oraz położenie punktów kluczowych poprzez usuwanie i dodawanie odpowiednich. Stworzono do tego tryby pracy które użytkownik może wybrać z rozwijanego menu. Zatroszczono się o weryfikacje ich prawidłowości, na przykład nie można dodać punktu kluczowego poza obszarem ograniczonym przez kontur. Również niepoprawne punkty konturu nie zostaną dodane. Dzięki opracowaniu algorytmu dodawania nowego punktu wszystko odbywa się sprawnie. Program reaguje wystarczająco sprawnie i nawet gdy użytkownik zdecyduje się szybko dodawać kolejne punkty kluczowe program się z nimi upora w nieznacznie większym czasie. Usunięcie punktu konturu w taki sposób że punkt kluczowy znajdzie się poza konturem spowoduje usunięcie punktu kluczowego jak również obiektów które znajdą się poza konturem.

\noindent\linia
\section{Zmiany względem specyfikacji}
W toku realizacji projektu wprowadzono wiele modyfikacji względem zakładanych na początku rozwiązań. Te najbardziej istotne wraz z wyjaśnieniem czemu zostały wprowadzone to:
\begin{itemize}
\item \textbf{zmiana algorytmu wyznaczania obszarów} - ze względu na istotność opisana w kolejnym rozdziale ,
\item \textbf{zmian sposobu rysowania obszarów} - była to zmiana wymuszona poprzez zmianę wyznaczania tych obszarów,
\item \textbf{modyfikacja interfejsu użytkownika} - podczas testów manualnych określono intuicyjność rozwiązania proponowanego w specyfikacjach, uznano iż dodanie trybów pracy rezygnując z dodatkowych menu kontekstowych wpłynie korzystnie na łatwość obsługi.
\end{itemize}
Wprowadzono również wiele innych zmian ale ze względu na niewielką istotność dla całości nie zostały one uwzględnione w tym dokumencie.

\noindent\linia
\section{Zmagania z wyznaczaniem optymalnych obszarów}
Szukając sposobu na sprostanie wyzwaniu wyznaczania optymalnych obszarów powstały trzy ścieżki:
\begin{enumerate}
\item Algorytm autorski,
\item Algorytm Fortune'a,
\item Algorytm ostateczny.
\end{enumerate}
\subsection{Algorytm autorski}
Po wstępnym zapoznaniu się z algorytmem Fortune'a, postanowiono poszukać bardziej zrozumiałego rozwiązania.
Tak powstała, przedstawiona poniżej, koncepcja wyznaczania optymalnych obszarów:
\begin{enumerate}
\item Otrzymane punkty kluczowe pogrupować w trójkąty przy pomocy triangulacji S-Hull.
\item Wyznaczyć środki otrzymanych trójkątów (ze wzorów matematycznych).
\item Połączyć środki sąsiadujących trójkątów (sąsiedzi mają wspólny bok).
\item W przypadku braku sąsiada poprowadzić półprostą przez środek trójkąta i środek boku bez sąsiada.
\end{enumerate}
Kiedy podana wyżej koncepcja była gotowa, po bliższych jej oględzinach uznano, że triangulacja w swoim stopniu skomplikowania nie ustępuje algorytmowi Fortune'a.
Biorąc pod uwagę ramy czasowe i pozostałe funkcjonalności, które muszą zostać zrealizowane w przewidzianym czasie, postanowiono dać szansę algorytmowi Fortune'a. Jego skuteczność i poprawność działania są znane historii w przeciwieństwie do ''algorytmu autorskiego'', dlatego postanowiono nie ryzykować pokaźnej straty zasobów czasowych na wypadek nieprawidłowości działania nowo wymyślonego algorytmu.
\subsection{Algorytm Fortune'a}
Praca nad zrozumieniem i implementacją algorytmu Fortune'a trwała do wieczora 31.12 ubiegłego roku.
Udało się zrozumieć jego działanie oraz nakreślić implementację, która znajduje się na gałęzi ''voronoi'' w projektowym repozytorium. Wersja ta działała częściowo poprawnie dla wybranych zbiorów danych. Podjęto próby zlokalizowania źródła błędów, które niestety zakończyły się niepowodzeniem.

Do roboczych testów manualnych użyto klas ''StdDraw'' oraz ''Stopwatch'' (źródło Github), które posłużyły tylko do wyświetlenia efektów pracy nieudanej implementacji algorytmu i nie rościmy sobie do nich praw autorskich. Klasy te nie weszły w skład naszej implementacji i nigdy nie było nawet takich planów. Służyły tylko i~wyłącznie do szybkich roboczych testów.

Z nastaniem roku 2019 dokonano bilansu efektów dotychczasowej pracy, poczynionych postępów oraz pozostałych zadań i zestawiono to wszystko z wyznaczonym terminem oddania projektu. W obliczu dwóch tygodni, które pozostały na skończenie projektu (i inne studenckie zobowiązania) oraz przegranej bitwy z tą implementacją (ale nie wojny), podjęto decyzję o porzuceniu tego ambitnego rozwiązania na rzecz pozostałych funkcjonalności. Byliśmy pewni, że prostsza implementacja pozwoli nam spełnić pozostałe wymagania projektu. Chcieliśmy uniknąć sytuacji, w której do tego stopnia skupimy się na wyznaczaniu diagramów Voronoi, że nie starczy nam czasu na pozostałe funkcje programu.
\subsection{Algorytm ostateczny}
Zastosowana implementacja wyznaczająca diagram Voronoi z punktów kluczowych polega na:
\begin{itemize}
\item ustaleniu dwuwymiarowej tablicy o określonej wielkości (to nasz plansza),
\item przeskalowaniu współrzędnych punktów kluczowych na wartości całkowite (np. 45,6 -> 456),
		
		Nasza implementacja pozwala na określanie współrzędnych z przedziału [0, 99.9] z dokładnością do jednego miejsca po przecinku.
\item przypisaniu każdego punktu tablicy do najbliższego mu punktu kluczowego (w punktach kluczowych znajduje się lista należących do nich punktów tablicy).
\end{itemize}

Dokładność powyższego rozwiązania to jedna komórka tablicy.

W przypadku dodawania punktu kluczowego przez użytkownika, aby uniknąć ponownego obliczania całego diagramu, zastosowano inne rozwiązanie. Algorytm przypisuje nowemu punktowi kluczowemu punkty tablicy zataczając coraz większe ''pierścienie'' wokół siebie tzn. przeszukuje tablice zaczynając od punktów zlokalizowanych najbliżej niego. W trakcie przeszukiwania weryfikuje, czy nowy punkt kluczowy jest najbliższy obecnie sprawdzanemu punktowi tablicy. Algorytm kończy prace, gdy wokół nowego punktu kluczowego pozostały już tylko punktu, które nie są mu najbliższe.

\noindent\linia
\section{Podsumowanie i wnioski}
Czas pracy nad projektem był zarówno angażujący jak i~rozwijający dla~wszystkich członków zespołu. Udało się rozwiązać zadany problem główny oraz zrealizować poboczne funkcjonalności. Efektem pracy jest w~pełni działający program o estetycznym wyglądnie i~zadowalającą sprawnością działania. Członkowie zespołu poszerzyli swoją wiedzę z zakresu algorytmów oraz nabyli praktyczne umiejętności w używaniu narzędzia \textit{JavaFX}. \\
\indent Z realizacji projektu wyciągnięto następujące wnioski:
\begin{itemize}
\item algorytm Fortune'a mimo niewątpliwej słuszności jego zastosowani był zbyt skomplikowany a~jego~odtworzenie zostało ocenione jako zajęcie mało rozwojowe,
\item podział zadań pomiędzy członków zaowocował bezkonfliktową równoległą pracą, stało się tak dzięki ciągłej komunikacji i~dobremu zaprojektowaniu system w specyfikacjach,
\item wprowadzanie zmian umożliwiło stworzenie lepszego programu wnioskiem z tego jest słuszność tworzenie oprogramowanie przy pomocy metodyk zwinnych.
\end{itemize}

\noindent\linia
\section{Ocena prowadzenia zajęć autorstwa Arkadiusza Michalaka}
Wychodząc na przeciw prośby Prowadzącego dołączam do sprawozdania moją głęboko subiektywną i nieformalną ocenę zajęć. Pragnę zaznaczyć, że mój sposób patrzenie i odbierania tych laboratoriów ulegał znacznym zmianom na przestrzeni całego semestru. 
\subsection{Trzy pierwsze zadania}
Będąc pełnymi energii i pozytywnego nastawienia w rozpoczynającym się semestrze została nam dana możliwość natychmiastowego tchnięcia tej energii w naukę i prace. Możliwość nie tyle została dana co szybko narzucona, uważam że zdecydowanie zbyt szybko. Narzucono bardzo żwawe tempo pracy. Nie tyle w samym programowaniu co w nauce do wejściówek. Dziwny dla wszystkich był fakt jak bardzo wejściówki wyprzedzały materiał realizowany na wykładzie. Trawestacja czyli temat powtarzający się na wszystkich trzech wejściówkach został wspomniany na wykładzie około 7 tygodnia semestru, czyli prawie miesiąc od zakończenie pierwszej części laboratoriów. To samo tyczy się drzew RBT czy algorytmu sortowania przez kopcowanie. Słuszne na wejściówkach były pytania z tematów związanych ściśle z samym programowanie gdyż tą wiedzę mieliśmy możliwość nabyć na pierwszym i drugim semestrze. Sam stosunek punktowania wejściówki/kodu uważam za dobry. Zmianą jaką bym sugerował co do tej części są jedne zajęcia wprowadzające i umożliwiające lepsze zapoznanie się z wymaganiami Prowadzącego odnośnie kodu, testów, wejściówek. Obowiązek uzyskania z tej części więcej niż 50\% dla pozytywnego zaliczenia laboratoriów wywiera dosyć dużą presje. Są to jedyne zajęcia spośród tych na które uczęszczałem gdzie w pierwszy miesiącu można pożegnać się z zaliczeniem. Ta presja wywarta na samym wstępne wpływa negatywnie na wielu studentów. Dla mnie co prawda jest motywująca ale to czyni mnie zdecydowaną mniejszością. Same algorytmy jakie mieliśmy do napisania oceniam w następujący sposób:
\begin{itemize}
\item kopiec - dobra rozgrzewka, algorytm łatwy w zrozumieniu,
\item sortowania - ciekawy mini projekt do realizacji mam tu głównie na myśli pisanie raportu i porównywanie napisanych przez siebie rozwiązań pod względem wydajności,
\item drzewo RBT - zdecydowanie zbyt trudy i obszerny projekt jak na coś co powinno być napisane z tygodnia z tydzień. Dodając do tego fakt iż nie został wtedy omówiony na wykładzie.
\end{itemize}
\subsection{Projekt indywidualny}
Najlepsza moim zdaniem część zajęć. Temat projektu był ciekawy, przy zdefiniowanych warunkach ciężko było znaleźć gotowe rozwiązanie, co motywowało do samodzielnego myślenia.
\subsection{Projekt zespołowy}

\noindent\linia

\end{document}




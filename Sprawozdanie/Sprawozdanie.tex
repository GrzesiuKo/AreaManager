\documentclass[a4paper,11pt]{article}
\usepackage{indentfirst}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}
\usepackage[top=2cm, bottom=2cm, left=1cm, right=1cm]{geometry}
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength\parindent{24pt}
\makeatletter
\newcommand{\linia}{\rule{\linewidth}{0.4mm}}
\renewcommand{\maketitle}{\begin{titlepage}
    \vspace*{2cm}
    \begin{center}\LARGE
    Politechnika Warszawska\\
    Wydział Elektryczny\\
    \end{center}
    \vspace{5cm}
    \noindent\linia
    \begin{center}
      \LARGE \textsc{\@title}
         \end{center}
     \linia
    \vspace{0.5cm}
    \begin{flushright}
    \begin{minipage}{5cm}
    \textit{Autor:}\\
    \normalsize \textsc{\@author} \par
    \end{minipage}
    \vspace{5cm}
     \end{flushright}
    \vspace*{\stretch{6}}
    \begin{center}
    \@date
    \end{center}
  \end{titlepage}
}
\makeatother
\author{Grzegorz Kopyt\\Arkadiusz Michalak}
\title{Sprawozdanie}
\usepackage{graphicx}

\fancyhf{}
\fancyhead[CO,CE]{ Grzegorz Kopyt Arkadiusz Michalak \\ Projekt grupowy - Sprawozdanie \\ \today }

\rfoot{\thepage{}/\pageref{LastPage}}

\begin{document}

\maketitle

\tableofcontents
\vspace{1cm}
\noindent\linia
\section{Cel powstania dokumentu}
Rozważanym w projekcie problemem był podział płaszczyzny na obszary optymalne względem punktów kluczowych. Poniższe sprawozdanie ma na celu podsumowanie pracy nad projektem i przedstawienie rozwiązania problemu. Dodatkowo została w nim zawarta subiektywna ocena sposobu prowadzenia laboratoriów przedmiotu Algorytmu i Struktury Danych.

\noindent\linia
\section{Opis problemu}
Podstawowym problemem był podział płaszczyzny ograniczonej konturem względem punktów kluczowych tak żeby dowolny punkt dzielonej płaszczyzny znajdował się bliżej swojego punktu kluczowego niż dowolnego innego. Istotnym zagadnieniem powiązanym z głównym problemem było przedstawienie graficzne tej płaszczyzny. Dodatkowo program miał umożliwiać nanoszenie na płaszczyznę obiektów. Kolejnym problemem była statystyk owych obiektów dla każdego obszaru jak również całej płaszczyzny. Ostatnie wymaganie problemowe to modyfikacja kontur ograniczającego płaszczyznę jak i usytuowanie punktów kluczowych na żywo. 

\noindent\linia
\section{Wysoko abstrakcyjny opis działania programu}
Współrzędne płaszczyzny na której operujemy zostały przybliżone do jednej cyfry po przecinku. To powoduje dyskretny podział na punkty co jest kluczowe dla działania algorytmu podziału.
Sposób działanie programu przedstawia się następująco:
\begin{itemize}
\item  wczytanie pliku danych od użytkownika,
\item  weryfikacja konturu pod względem wypukłości i spójności,
\item  weryfikacja punktów kluczowych pod względem przynależności do zadanego konturu
\item jeśli po weryfikacji dane są poprawne rozpoczyna się obliczanie przynależności punktów płaszczyzny do punktów kluczowych:
\begin{itemize}
\item dla każdego punktu z zakresu od 0 do 99,9 znajdujemy najbliższy  punkt kluczowy porównując odległości do wszystkich punktów,
\item do punktu kluczowego znajdującego się najbliżej przypisujemy obecnie sprawdzany punkt.
\end{itemize}
\item utworzona w ten sposób struktura punktów kluczowych z przypisanymi punktami płaszczyzny posłuży do odzwierciedlenia obszarów graficznie,
\item następnie dodawane są obiekty użytkownika,
\item weryfikowana jest ich poprawność oraz określane jest przynależność do punktu kluczowego analogicznie jak dla punktów płaszczyzny,
\item następnie przy użyciu biblioteki graficznej rysowane jest obszar ograniczony konturem, podzielony względem punktów kluczowych, same punkty kluczowe i obiekty użytkownika.
\end{itemize}


\noindent\linia
\section{Efekty działania programu}
W czasie trwanie projektu udało się zrealizować wszystkie wymagane funkcjonalności. Najlepszą prezentacją tego jak działa program jest jego uruchomienie. Jednak krótki opis działania poszczególnych funkcjonalności zostanie wypunktowany poniżej.
\subsection{Obsługa plików}
Program dysponuje wczytywaniem plików tekstowych opisujące parametry do analizy. Umożliwia również podłożenie tła będące plikiem graficznym w jednym z formatów \textit{.png , .jpeg , .gif}. Wybór plików odbywa się w sposób intuicyjny, pozwalający użytkownikowi wskazać tylko pliki o odpowiednim rozszerzeniu z dowolnego folderu komputera. Przy wczytywaniu pliku tekstowego zatroszczono się o szczegółową weryfikacje jego poprawności. Umożliwia to zakomunikowanie użytkownikowi w której linii pojawiły się błędne dane i jakiego rodzaju był to błąd.
\subsection{Rysowanie obszaru}
W sposób wiarygodny przy użyciu narzędzia \textit{canvas} odzwierciedlany jest obliczony podział. Obszary są kolorowe co dodaje atutów wizualnych całości programu. Punktom kluczowym ze względu na ich istotność przypisano kolor czerwony i większy rozmiar względem obiektów użytkownika. Całość charakteryzuje się dużą przejrzystością i czytelnością nawet po podstawieniu kolorowego tła.
\subsection{Statystyka obiektów użytkownika}
Weryfikowane zgodnie z założeniami obiektu użytkownika również są nanoszone na analizowany obszar. Przypisano im kolor fioletowy. Najbardziej istotnym działaniem jest podsumowywanie obiektów użytkownika na danym obszarze. W trybie pracy \textbf{"Wyświetlanie statystyk"} użytkownik może w prosty sposób kliknąć wybrany obszar i wyświetlić wybrany, spośród trzech, rodzaj statystyk:
\begin{itemize}
\item listę wszystkich obiektów,
\item pogrupowaną listę obiektów,
\item liczbę mieszkańców.
\end{itemize}
Wyświetlone zostaną w nowym oknie, ta część programu działa bardzo sprawnie gdyż przynależności obiektów są weryfikowane podczas modyfikacji analizowanego obszaru.
\subsection{Modyfikacja na żywo}
Program umożliwia zmianę konturu jaki i położenie punktów kluczowych poprzez usuwanie i dodawanie odpowiednich. Stworzone do tego tryby pracy które użytkownik może wybrać z rozwijanego menu. Zatroszczono się o weryfikacje ich prawidłowości, na przykład nie można dodać punktu kluczowego poza obszarem ograniczonym przez kontur. Również niepoprawne punkty konturu nie zostaną dodane. Dzięki opracowaniu algorytmu dodawania nowego punktu wszystko odbywa się sprawnie. Program reaguje wystarczająco szybko i nawet gdy użytkownik zdecyduje się szybko dodawać kolejne punkty kluczowe program się z nimi upora w nieznacznie większym czasie. Usunięcie punktu konturu w taki sposób że punkt kluczowy znajdzie się poza konturem spowoduje usunięcie punktu kluczowego jak również obiektów które znajdą się poza konturem.

\noindent\linia
\section{Zmiany względem specyfikacji}

\noindent\linia
\section{Zmagania z wyznaczaniem optymalnych obszarów}
Szukając sposobu na sprostanie wyzwaniu wyznaczania optymalnych obszarów powstały trzy ścieżki:
\begin{enumerate}
\item Algorytm autorski,
\item Algorytm Fortune'a,
\item Algorytm ostateczny.
\end{enumerate}
\subsection{Algorytm autorski}
Po wstępnym zapoznaniu się z algorytmem Fortune'a, postanowiono poszukać bardziej zrozumiałego rozwiązania.
Tak powstała, przedstawiona poniżej, koncepcja wyznaczania optymalnych obszarów:
\begin{enumerate}
\item Otrzymane punkty kluczowe pogrupować w trójkąty przy pomocy triangulacji S-Hull.
\item Wyznaczyć środki otrzymanych trójkątów (ze wzorów matematycznych).
\item Połączyć środki sąsiadujących trójkątów (sąsiedzi mają wspólny bok).
\item W przypadku braku sąsiada poprowadzić półprostą przez środek trójkąta i środek boku bez sąsiada.
\end{enumerate}
Kiedy podana wyżej koncepcja była gotowa, po bliższych jej oględzinach uznano, że triangulacja w swoim stopniu skomplikowania nie ustępuje algorytmowi Fortune'a.
Biorąc pod uwagę ramy czasowe i pozostałe funkcjonalności, które muszą zostać zrealizowane w przewidzianym czasie, postanowiono dać szansę algorytmowi Fortune'a. Jego skuteczność i poprawność działania są znane historii w przeciwieństwie do ''algorytmu autorskiego'', dlatego postanowiono nie ryzykować pokaźnej straty zasobów czasowych na wypadek nieprawidłowości działania nowo wymyślonego algorytmu.
\subsection{Algorytm Fortune'a}
Praca nad zrozumieniem i implementacją algorytmu Fortune'a trwała do wieczora 31.12 ubiegłego roku.
Udało się zrozumieć jego działanie oraz nakreślić implementację, która znajduje się na gałęzi ''voronoi'' w projektowym repozytorium. Wersja ta działała częściowo poprawnie dla wybranych zbiorów danych. Podjęto próby zlokalizowania źródła błędów, które niestety zakończyły się niepowodzeniem.

Do roboczych testów manualnych użyto klas ''StdDraw'' oraz ''Stopwatch'' (źródło Github), które posłużyły tylko do wyświetlenia efektów pracy nieudanej implementacji algorytmu i nie rościmy sobie do nich praw autorskich. Klasy te nie weszły w skład naszej implementacji i nigdy nie było nawet takich planów. Służyły tylko i wyłącznie do szybkich roboczych testów.

Z nastaniem roku 2019 dokonano bilansu efektów dotychczasowej pracy, poczynionych postępów oraz pozostałych zadań i zestawiono to wszystko z wyznaczonym terminem oddania projektu. W obliczu dwóch tygodni, które pozostały na skończenie projektu (i inne studenckie zobowiązania) oraz przegranej bitwy z tą implementacją (ale nie wojny), podjęto decyzję o porzuceniu tego ambitnego rozwiązania na rzecz pozostałych funkcjonalności. Byliśmy pewni, że prostsza implementacja pozwoli nam spełnić pozostałe wymagania projektu. Chcieliśmy uniknąć sytuacji, w której do tego stopnia skupimy się na wyznaczaniu diagramów Voronoi, że nie starczy nam czasu na pozostałe funkcje programu.
\subsection{Algorytm ostateczny}
Zastosowana implementacja wyznaczająca diagram Voronoi z punktów kluczowych polega na:
\begin{itemize}
\item ustaleniu dwuwymiarowej tablicy o określonej wielkości (to nasz plansza),
\item przeskalowaniu współrzędnych punktów kluczowych na wartości całkowite (np. 45,6 -> 456),
		
		Nasza implementacja pozwala na określanie współrzędnych z przedziału [0, 99.9] z dokładnością do jednego miejsca po przecinku.
\item przypisaniu każdego punktu tablicy do najbliższego mu punktu kluczowego (w punktach kluczowych znajduje się lista należących do nich punktów tablicy).
\end{itemize}

Dokładność powyższego rozwiązania to jedna komórka tablicy.

W przypadku dodawania punktu kluczowego przez użytkownika, aby uniknąć ponownego obliczania całego diagramu, zastosowano inne rozwiązanie. Algorytm przypisuje nowemu punktowi kluczowemu punkty tablicy zataczając coraz większe ''pierścienie'' wokół siebie tzn. przeszukuje tablice zaczynając od punktów zlokalizowanych najbliżej niego. W trakcie przeszukiwania weryfikuje, czy nowy punkt kluczowy jest najbliższy obecnie sprawdzanemu punktowi tablicy. Algorytm kończy prace, gdy wokół nowego punktu kluczowego pozostały już tylko punktu, które nie są mu najbliższe.

\noindent\linia
\section{Podsumowanie i wnioski}

\noindent\linia
\section{Ocena prowadzenia zajęć}

\noindent\linia

\end{document}




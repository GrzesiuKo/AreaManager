\documentclass[a4paper,11pt]{article}
\usepackage{indentfirst}
\setlength\parindent{24pt}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}
\usepackage[top=2cm, bottom=2cm, left=1cm, right=1cm]{geometry}
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\makeatletter
\newcommand{\linia}{\rule{\linewidth}{0.4mm}}
\renewcommand{\maketitle}{\begin{titlepage}
    \vspace*{2cm}
    \begin{center}\LARGE
    Politechnika Warszawska\\
    Wydział Elektryczny\\
    \end{center}
    \vspace{5cm}
    \noindent\linia
    \begin{center}
      \LARGE \textsc{\@title}
         \end{center}
     \linia
    \vspace{0.5cm}
    \begin{flushright}
    \begin{minipage}{5cm}
    \textit{Autor:}\\
    \normalsize \textsc{\@author} \par
    \end{minipage}
    \vspace{5cm}
     \end{flushright}
    \vspace*{\stretch{6}}
    \begin{center}
    \@date
    \end{center}
  \end{titlepage}
}
\makeatother
\author{Grzegorz Kopyt\\Arkadiusz Michalak}
\title{Specyfikacja Implementacyjna}
\usepackage{graphicx}
\fancyhf{}
\rfoot{\thepage{}/\pageref{LastPage}}
\begin{document}

\maketitle

\tableofcontents
\vspace{1cm}
\noindent\linia

\section{Wstęp teoretyczny}
Dokument ten dotyczy programu realizowanego w ramach ,,Projektu Zespołowego 2018/2019".

Ma on za zadanie przedstawić problem rozważany w projekcie od strony czysto praktycznej. Zagadnienie podziału płaszczyzny na optymalne obszary doczekało się wielu koncepcji rozwiązań. Szczegóły algorytmów użytych w naszym rozwiązaniu znajdują się w \textbf{rozdziale 2}. 

\noindent\linia
\section{Opis algorytmu}
\subsection{Sprawdzanie wypukłości konturu}
Wszystkie punkty konturu podane przez użytkownika przechowywane będą w klasie \textit{Contour}.

Na podstawie algorytmu Jarvisa zostaną one podzielone na te, które wejdą w skład konturu oraz na te, które zostaną zignorowane. Punkty będą ignorowane, jeśli podany kontur nie będzie wypukły. Wtedy algorytm stworzy wypukły kontur, na podstawie podanych punktów, ignorując te, które uzna za burzące wypukły kształt figury. Punkty wchodzące w skład konturu zostaną zachowane w kolejności łączenia.

\noindent
Algorytm będzie działał następująco:
\begin{enumerate}
\item Wybierze dwa punkty \textit{P} i \textit{Q}.

\textit{P} to punkt o najmniejszej współrzędnej Y (oraz X, jeśli więcej punktów ma tą samą Y). \textit{Q} to punkt o największej współrzędnej Y (oraz X, jeśli więcej punktów ma tą samą Y).

\item Wyznaczy prawą część konturu:

\textit{C} - obecny punkt (początkowo \textit{P}), \textit{N} - następny punkt konturu 
\begin{enumerate}
\item Znajdzie \textit{N}, dla którego cosinus kąta między wektorem \textit{CN} a\textit{ [1,0]} jest największy,
\item \textit{C} staje się \textit{N}, a \textit{N} to kolejny punkt,
\item Jeśli \textit{N} = \textit{Q} skończy iteracje.
\end{enumerate}
Powyższe instrukcje wykona w pętli.

\item Wyznaczy lewą część konturu:

\textit{C} - obecny punkt (początkowo \textit{Q}), \textit{N} - następny punkt konturu 
\begin{enumerate}
\item Znajdzie \textit{N}, dla którego cosinus kąta między wektorem \textit{CN} a\textit{ [-1,0]} jest największy,
\item \textit{C} staje się \textit{N} a \textit{N} to kolejny punkt,
\item Jeśli \textit{N} = \textit{P} skończy iteracje.
\end{enumerate}
Powyższe instrukcje wykona w pętli.
\end{enumerate}

\noindent\linia
\section{Diagramy klas}
\subsection{Statistics}
\includegraphics[scale=0.28]{statisticPackage.png} 

\noindent\linia
\section{Opis ważniejszych metod}
\subsection{Pakiet Statistics}
\begin{itemize}
\item Klasa \textbf{Statistics} zawiera trzy publiczne metody które odpowiadają na wymagania odnośnie prowadzenia i~wyświetlania statystyk. Po zarejestrowaniu żądania użytkownika wywoływana jest odpowiednia metoda dla przykładu omówmy metodę \textbf{printAllObjectList:}
\begin{enumerate}
\item Określany jest obszar którego obiekty mają zostać wyświetlone, w tym celu wywoływana jest metoda \textbf{findKeyPoints:}
\begin{enumerate}
\item metoda \textbf{findKeyPoints} określa odległość punktu od wszystkich punktów kluczowych i zwraca jako wartość najmniej odległy.
\end{enumerate}
\item Metoda iteruje po listach obiektów zawartych w klasie \textbf{UserObject}.
\item Obiekty dla których wartość pola memberOf jest wyszukanym wcześniej punktem kluczowym zostają wypisane do przewijanego pola tekstowego zawartego w interfejsie. .
\end{enumerate}
Analogiczne działania należy wykonać w pozostałych metodach, grupując obiekty zgodnie z typami w metodzie \textbf{printGroupedObjectList}, lub zliczając mieszkańców w metodzie \textbf{printResidentsNumber}. Metoda \textbf{recheckData} wywoływana jest za każdym razem gdy nastąpi modyfikacja punktów kluczowych lub granic konturu i sprawdza do jakiego punktu kluczowego należą obiekty oraz czy nie znalazły się poza granicami konturu.
\item Klasa \textbf{UserObject} stanowi bazową klasę opisującą dowolny obiekt jakie może zostać naniesione na obszar konturu. Nie będzie ona udostępniać publicznych konstruktorów, a jedynie metody dodania, w celu hermetyzacji sposobu tworzenia nowych obiektów. Przy tworzeniu obiekt zostanie wpisany w listę statystyki, zostanie też, przy użyciu metody \textbf{checkMembership}, określone do obszaru którego punktu kluczowego należy obiekt. Taki sposób organizacji pozwoli na łatwą rozbudowę bazy obiektów o nowe typy.
\end{itemize}

\noindent\linia

\section{Testy}
\begin{itemize}
\item 
\end{itemize}

\noindent\linia
\section{Informacje o sprzęcie i oprogramowaniu}
Program będzie pisany w języku Java wersji 9.0.4 ze wsparciem biblioteki JavaFX oraz środowiska Intellij IDEA.

Zostanie przetestowany na komputerach:
\begin{enumerate}
\item Lenovo G510 o procesorze Intel Core i5 2.5GHz, pamięci RAM 6GB, karcie graficznej AMD Radeon
HD 8570M i systemie operacyjnym Windows 10,
\item Asus X7500J o procesorze Intel Core i7 2.4GHz, pamięci RAM 8GB, karcie graficznej NVIDIA GeForce GT 740M i systemie operacyjnym Windows 10. 
\end{enumerate} 
\noindent\linia

\end{document}



